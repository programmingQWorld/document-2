MySQL查询优化 
（一）为什么要优化 
    （一）关注的指标 
    （二）MySQL优化目标 优化的目的主要可分为以下四个：
     1）提高资源利用率； 2）避免短板效应； 3）提高系统吞吐量； 4）同时满足更多用户的在线需求。 
     简单来说，'优化的目的'是'为了提高资源的利用率'，让资源充分发挥价值。
     常见场景下，一台服务器'有4大资源'： CPU、内存、网络和磁盘，
     一旦其中某个资源出现问题，整个服务器提供服务的能力就会变差。
     优化的最终目的是为了同时满足更 多用户的在线需求。 
     
     MySQL优化目标 MySQL优化目标主要有3个： 
     第一，减少磁盘IO，在数据库中主要是来自于像全表扫描这种扫描大量数据块的场景，
     然后就是日志以及数据块的写入所带来的压力。 
     
     第二，减少网络带宽，主要是包括两个方面，第一，SQL查询时，返回太多数据；第二，插入场景下，交互次数过多。 
     第三，降低CPU的消耗，主要包括三个方面，第一，MySQL本身的逻辑读，第二，额外的计算操作，比如排序分组(order by group by），第三，是聚合函数(max,min,sum..）。 
     
     
     1. 有物理读的地方，一定会有逻辑读； 
     物理读：将数据从磁盘上的文件写入到buffer cache的过程； 
     逻辑读：将数据从buffer cache内存读取到PGA给用户的过程 
     总结如下：
      1.减少磁盘IO ·全表扫描 ·磁盘临时表 ·日志、数据块fsync 
      2.减少网络带宽 ·返回太多数据 ·交互次数过多 
      3.降低CPU消耗 ·排序分组。order by, group by ·聚合函数。max,min,sum...
      
       逻辑读 图片(可略过) 上图所示的金字塔，
       
       从下往上列了'4个查询的优化手段'，依次是'SQL及索引优化'、'库表结构优化'、'系统配置优化'、'硬件优化'。 

       对于单个MySQL来讲，从下往上优化，成本是逐步提升的，但效果反而越来越差。
       通常来说，SQL及索引调优往往不需要花费过多成本，却可以取到显著效果。 
       
优化流程及思路 关注的指标 SQL优化常规流程及思路。需要关注以下六个指标： 

第一：CPU使用率，是SQL查询关键资源指标，CPU的消耗一般来自于数据扫描与显式计算。 
第二：IOPS，是衡量磁盘压力的指标，它指的是每秒IO请求的次数，对数据库来说，IOPS是物理读写的关键资源指标。 
第三：QPS/TPS，指MySQL数据库的吞吐量，也能在一定程度上反映应用系统的业务压力。 
第四：会话数/活跃会话数，一般在应用配置问题，没有合理使用到连接池，或者SQL执行效率较差的时候出现这类的指标异常问题，这些情况会导致数据库的Server端产生大量的会话，甚至会积压大量的活跃会话。 
第五：Innodb逻辑读/物理读，这是主要用于反映数据库实例整体查询效率的引擎指标。 
第六：临时表，通常来说，产生临时表往往意味着SQL执行效率的下降 

总结如下： CPU使用率 SQL查询关键资源指标 数据扫描、显式计算 IOPS 每秒IO请求次数 物理读写关键资源指标 QPS/TPS 吞吐量 业务压力 会话数/活跃会话数 应用配置 执行效率 Innodb逻辑读/物理读 反映整体查询效率的引擎指标 临时表 导致SQL执行效率下降的特殊行为 

合理监控 事实上我们实际分析问题的时候，可能还会涉及到很多其他的资源指标，
而这些指标数据都需要通过一个合理的方式来获取， 在比较传统的时代，
是通过Top、 lostat、 Sar、 Dstat、 show status等命令去看。 

下图所示是袋鼠云EasyDO智能运维平台，可以看到整个业务系统里各个数据库示例，包括CPU、IOPS等我们所关心的指标。 

MySQL优化流程 

第一步，'构建完备的监控体系'。为了获取性能数据，分析及诊断问题，需要建立一套相对完备的监控体系。
对于这块， 首先需要有细致合理的告警，其次有多维度图形化指标，只有做到这两点，才可以暴露整个系统的性能缺陷，从而掌握大规模资源。 

第二步，'当出现问题'，或者当我们发现资源指标趋势跟预想不一致的时候，需要分析定位问题，这个过程就是'性能诊断'。 
一般关注5点，第一，发生'异常时间区间'；第二，'系统日志'以及'数据库的错误日志'；第三，'Slow Log日志'；第四，通过合理手段'对SQL执行统计'；第五，'Session会话分析'。 
诊断分析之后，'定位到某些会话或者某些SQL语句'，可以'看到异常行为'。 

第三步，'分析业务逻辑'，包括3点， 第一，读写需求，请求量是不是正常； 第二，事务精简，事务是不是有设计上的缺陷； 第三，资源调用关系，比如SQL执行本身不慢，但是因为资源调用关系，出现锁等待的问题。 
以上问题分析清楚之后，接下来才是要'对真正有性能问题的SQL'进行优化。 

第四步，SQL优化，关于这块主要包括4点， 
第一，Explain查看SQL执行计划； 第二，SQL改写； 第三，索引调整； 第四，˜参数调整。

总结如下： 构建完备的监控体系 细致合理的告警 多维度图形化指标 暴露性能缺陷，掌控大规模资源 分析定位问题 异常时间区间 System log、 DB Error Log Slow Log SQL执行统计 session 分析业务逻辑 读写需求 事务精简 资源调用关系 
SQL优化 explain SQL改写 索引调整 参数调整 S

QL优化原则与方法 

1.优化原则 'SQL优化原则'主要有两点：'减少数据访问量'与'减少计算操作'。 (lincq：我把第一个理解为数据的扫描量) 
1.减少访问量：'数据存取'是'数据库系统最核心功能'，所以'IO'是数据库系统中'最容易出现性能瓶颈'，
'减少SQL访问IO量'是SQL优化的第一步； 数据块的逻辑读也是产生CPU开销的因素之一。 

减少访问量的'方法'：'创建合适的索引'、'减少不必访问的列'、'使用索引覆盖'、'语句改写'。

 2.减少计算操作：'计算操作进行优化'也是'SQL优化的重要方向'。SQL中'排序、分组、多表连接'操作等计算操作，
 都是'CPU消耗的大户'。 减少SQL计算操作的'方法'：'排序列加入索引'、'适当的列冗余'、'SQL拆分'、'计算功能拆分'。 
 关于SQL优化方法，
 包括5点 
 
 1）'创建索引减少扫描量' 
 2）调整索引减少计算量； 
 3）索引覆盖（减少不必访问的列，'避免回表查询'）； 
 4) SQL改写； 
 5）干预执行计划； 
 
 原理解析 b+tree索引 如上图所示，B+ Tree Index索引分为3个部分：根、枝、叶。 
 核心特点是根和枝不存储数据，行高比较固定。
 通过“B+Tree”索引'取数据'，'必然经过'根枝叶三个'节点路径'，取数据的'代价比较稳定'；
 另外一点，'叶子节点上的数据'是'有序存储'的。 Innodb Table Innodb 是MySOL的核心存储引擎，
 Innodb Table是lOT有序存储， 核心概念为：Innodb的表数据按照"B+Tree" 的结构进行组织，
 表数据本身是“B+Tree”索引的叶子节点。 如下图所示，'每张表'，也就是'每个存储段'，
 实际是在MySOL里构建了一个“B+ Tree”索引的树状结构，
 段的物理存储跟其他关系数据库的存储方式一样分区和块。 segment(段) extent(区,范围面积) 
 
 page 索引检索过程 把二级索引理解为非主键索引 如上图所示有三个流程，
 上面两块是'二级索引'，下面是属于'主键索引'，也叫'聚集索引'，是'Innodb表的数据本身'，
 依次看这三个流程： 第一，非主键查询，入口是从二级索引，通过二级索引，
 第一个过程返回聚集索引的ID；第二个过程是回表，相当于再做一次数据检索，然后从聚集索引中获取数据。 
 第二，'主键查询'，入口是直接通过聚集索引的ID，可以在聚集索引中获取数据。 
 第三，'覆盖索引'，入口是二级索引，直接从二级索引当中获取数据。 
 
 MySQL的行为 MySQL SQL执行过程 
 1. 执行过程示例 如上图所示，MySQL的执行的过程包括： 
 
 1）客户端提交一条语句； 
 2）先在查询缓存查看是否存在对应的缓存数据，如有则直接返回(一般有的可能性极小，因此一般建议关闭查询缓存）； 
 3）交给'解析器'处理，解析器会将提交的语句'生成一个解析树'； 
 4）'预处理器'会处理解析树，'形成新的解析树'。这一阶段'存在一些SQL改写的过程'； 
 5）'改写后的解析树'提交给'查询优化器'。查询优化器'生成执行计划'； 
 6）'执行计划'交由执行引擎调用存储引擎接口，完成执行过程。这里要注意，'MySQL的Server层和Engine层是分离的'； 
 7）'最终的结果'由'执行引擎返回'给客户端，如果'开启查询缓存'的话，则会缓存。 
 
 
 2.SQL执行顺序 (8) SELECT (9) DISTINCT (1) FROM (3) JOIN (2) ON (4) WHERE (5) GROUP (6) WITH {CUBE|ROLLUP} (7) HAVING (10) ORDER BY (11) LIMIT 
 
 
 关于SQL的执行顺序，在某些时候也可以给我们一些指导性建议。比如Where条件和Order by，在通常情况下，SQL语 句先获取数据，再做Select操作，先获取数据再返回到Server端结果集的存储区之后进行排序，从这里我们可以假设如 果通过索引获取数据，那么在取数据时，数据排序就已经完成，相当于MySQL存储引擎的层面已经做了优化，而不需要 再增加额外的排序计算操作。 MySQL优化器与执行计划 1.查询优化器 '查询优化器的主要作用'是用'来负责生成SQL语句的执行计划'。优化器是'数据库的核心价值'所在，它是数据库的“大脑” 优化SQL某种意义上就是理解优化器的行为。 在MySQL里面，'优化的依据'是执行成本，它的本质是CBO，也就是说'执行计划的生成是基于成本'的。目前MySQL优化 器没有那么完善，执行成本主要'基于行数'而定。优化器'工作的前提'是了解数据，'工作的目的'是'解析SQL，生成执行计划'。 总结如下： 负责生成 SQL 语句的有效执行计划的数据库组件； 优化器是数据库的核心价值所在，它是数据库的“大脑” 优化SQL，某种意义上就是理解优化器的行为； 优化的依据是执行成本(CBO)； 优化器工作的前提是了解数据，工作的目的是解析SQL，生成执行计划。 2.查询优化器工作过程 如上图所示，查询优化器工作过程包括： 1）'词法分析'、'语法分析'、'语义检查'； 2）预处理阶段（查询改写等）； 3）查询优化阶段，可详细划分为'逻辑优化'、'物理优化'两部分 逻辑优化：把SQL交给查询优化器之后，会去做相应的'改写'动作。 物理优化：过程是优化器'生成'获取去扫描数据的'路径'。 4）查询优化器'优化依据'，'来自于' '代价估算器估算结果'(它会调用统计信息作为计算依据)； 5）交由执行器执行。 3.查看和干预执行计划 在MySQL里查看SQL的执行计划'直接通过Explain关键词'就可以了，或者我们可以'添加Extended关键字'，它会展示 MySQL优化器的逻辑优化改写过程。 1.执行计划 explain [extended] SOL Statement explain select * from payment where rental _=d > 1000 order by payment_date; id :1 select_type :SIMPLE table:payment ALL type:fk_payment_rental possible keys:NULL key:NULL key_ler:NULL ref:15511 rows:Using where; Extra:Using filesort 1 row in set (0.00 sec) 对于MySQL执行计划的获取，我们可以通过explain方式来查看，explain方式看似简单，实际上包含的内容很多， 尤其是输出结果中的type类型列。理解这些不同的类型，对于我们SQL优化举足轻重， 本文仅描述explian输出结果中的type列，同时给出其演示。 有关explian输出的全描述，可以参考：MySQL EXPLAIN SQL 输出信息描述 一、EXPLAIN 语句中type列的值type： 连接类型 system 表只有一行 const '表最多只有一行匹配'，通用用于'主键'或者'唯一索引'比较时 eq_ref 每次与之前的表合并行都只在该表读取一行，这是'除了system，const之外最好的一种'，'特点是使用='， 而且索引的所有部分都参与join且索引是主键或非空唯一键的索引 ref 说明：如果每次只'匹配少数行'，那就是比较好的一种，'使用=或<=>'，可以是'左覆盖索引'或'非主键'或'非唯一键' eg:非唯一性索引扫描或者，返回'匹配某个单独值的所有行'。常见于使用'非唯一索引'即唯一索引的非唯一前缀进行的查找 explain select * from payment where customer_id=305\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: payment type: ref possible_keys: idx_fk_customer_id key: idx_fk_customer_id key_len: 2 ref: const rows: 25 Extra: 1 row in set (0.00 sec) ps:'idx_fk_customer_id'为表payment上的'外键索引'，且'存在多个不同的值' fulltext 全文搜索 ref_or_null 与ref类似，但包括NULL index_merge 表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。 这个比较复杂，目前的理解是'合并单表的范围索引扫描'（如果成本估算比普通的range要更优的话 unique_subquery 在in子查询中，就是value in (select...)把形如“select unique_key_column”的子查询替换。 PS：所以不一定in子句中使用子查询就是低效的！ index_subquery 同上，但把形如”select non_unique_key_column“的子查询替换 range index 常数值的范围 a.当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）； b.以索引顺序从索引中查找数据行的全表扫描（无 Using Index）； c.如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思； d.如单独出现，则是用读索引来代替读行，但不用于查找 all 全表扫描 当我们'认为SQL的执行计划不合理'时，可以通过'适当的手段'，'强制加索引'或者'强制驱动表的顺序'，通过这种hints方式干预 SQL的执行计划。另外'MySQL查询优化器'的一些'关键特性'，我们也可以通过控制优化器开关的参数，从而控制优化器相关的行为。 hints[提示，暗示] 2.优化器开关 show variables like 'optimizer_switch' mysql> show var iables Like 'opt optimizer_switch'\G Variable_name: opt optimizer_switch Value: index_ merge=on, index merge_ un ion=on, index merge_ sort. un ion=on， index_ merge. intersection=on, eng ine _condit ion pushdown=on, index_condit ion_ pushdown=on,mrr=on, mrr cost based=on, block_ nested_ Loop=on,batched key ac cess=off,materialization=on, semijo in=on, loosescan=on, firstmatch=on, duplicateweedout=on, subquery_ materialization cost based=on,use_ index_extens ions=on, condit ion_fanout_ filter=on, der ived merge=on T row in set (0.01 sec) 3.Processlist 另一种观测MySQL行为的常用手段就是Processlist。通过Processlist，我们可以看到当前在MySQL中执行的所有SQL 语句，有没有异常的会话或比较特殊的SQL状态。查看会话操作可以通过2种途径： 第一，show [full] processlist; 第二，information_schema.processlist。 这里列出了几种常见的异常行为： 1）Copy to tmp table 出现在某些Alter Table语句的Copy Table操作。 注：当Where条件中的过滤字段为覆盖索引的前缀列，而Order by字段是第二个索引列时，只有Where条件是Const匹配 时，才可以通过索引消除排序，而between…and或>?、MySQL查询优化 （一）为什么要优化 （一）关注的指标 （二）MySQL优化目标 优化的目的主要可分为以下四个： 1）提高资源利用率； 2）避免短板效应； 3）提高系统吞吐量； 4）同时满足更多用户的在线需求。 简单来说，'优化的目的'是'为了提高资源的利用率'，让资源充分发挥价值。常见场景下，一台服务器'有4大资源'： CPU、内存、网络和磁盘，一旦其中某个资源出现问题，整个服务器提供服务的能力就会变差。优化的最终目的是为了同时满足更 多用户的在线需求。 MySQL优化目标 MySQL优化目标主要有3个： 第一，减少磁盘IO，在数据库中主要是来自于像全表扫描这种扫描大量数据块的场景，然后就是日志以及数据块的写入所带来的压力。 第二，减少网络带宽，主要是包括两个方面，第一，SQL查询时，返回太多数据；第二，插入场景下，交互次数过多。 第三，降低CPU的消耗，主要包括三个方面，第一，MySQL本身的逻辑读，第二，额外的计算操作，比如排序分组(order by group by），第三，是聚合函数(max,min,sum..）。 1. 有物理读的地方，一定会有逻辑读； 物理读：将数据从磁盘上的文件写入到buffer cache的过程； 逻辑读：将数据从buffer cache内存读取到PGA给用户的过程 总结如下： 1.减少磁盘IO ·全表扫描 ·磁盘临时表 ·日志、数据块fsync 2.减少网络带宽 ·返回太多数据 ·交互次数过多 3.降低CPU消耗 ·排序分组。order by, group by ·聚合函数。max,min,sum... ·逻辑读 图片(可略过) 上图所示的金字塔，从下往上列了'4个查询的优化手段'，依次是'SQL及索引优化'、'库表结构优化'、'系统配置优化'、'硬件优化'。 对于单个MySQL来讲，从下往上优化，成本是逐步提升的，但效果反而越来越差。通常来说，SQL及索引调优往往不需要花费过多成本，却可以取到显著效果。 优化流程及思路 关注的指标 SQL优化常规流程及思路。需要关注以下六个指标： 第一：CPU使用率，是SQL查询关键资源指标，CPU的消耗一般来自于数据扫描与显式计算。 第二：IOPS，是衡量磁盘压力的指标，它指的是每秒IO请求的次数，对数据库来说，IOPS是物理读写的关键资源指标。 第三：QPS/TPS，指MySQL数据库的吞吐量，也能在一定程度上反映应用系统的业务压力。 第四：会话数/活跃会话数，一般在应用配置问题，没有合理使用到连接池，或者SQL执行效率较差的时候出现这类的指标异常问题，这些情况会导致数据库的Server端产生大量的会话，甚至会积压大量的活跃会话。 第五：Innodb逻辑读/物理读，这是主要用于反映数据库实例整体查询效率的引擎指标。 第六：临时表，通常来说，产生临时表往往意味着SQL执行效率的下降 总结如下： CPU使用率 SQL查询关键资源指标 数据扫描、显式计算 IOPS 每秒IO请求次数 物理读写关键资源指标 QPS/TPS 吞吐量 业务压力 会话数/活跃会话数 应用配置 执行效率 Innodb逻辑读/物理读 反映整体查询效率的引擎指标 临时表 导致SQL执行效率下降的特殊行为 合理监控 事实上我们实际分析问题的时候，可能还会涉及到很多其他的资源指标，而这些指标数据都需要通过一个合理的方式来获取， 在比较传统的时代，是通过Top、 lostat、 Sar、 Dstat、 show status等命令去看。 下图所示是袋鼠云EasyDO智能运维平台，可以看到整个业务系统里各个数据库示例，包括CPU、IOPS等我们所关心的指标。 MySQL优化流程 第一步，'构建完备的监控体系'。为了获取性能数据，分析及诊断问题，需要建立一套相对完备的监控体系。对于这块， 首先需要有细致合理的告警，其次有多维度图形化指标，只有做到这两点，才可以暴露整个系统的性能缺陷，从而掌握大规模资源。 第二步，'当出现问题'，或者当我们发现资源指标趋势跟预想不一致的时候，需要分析定位问题，这个过程就是'性能诊断'。 一般关注5点，第一，发生'异常时间区间'；第二，'系统日志'以及'数据库的错误日志'；第三，'Slow Log日志'；第四，通过合理手段'对SQL执行统计'；第五，'Session会话分析'。 诊断分析之后，'定位到某些会话或者某些SQL语句'，可以'看到异常行为'。 第三步，'分析业务逻辑'，包括3点， 第一，读写需求，请求量是不是正常； 第二，事务精简，事务是不是有设计上的缺陷； 第三，资源调用关系，比如SQL执行本身不慢，但是因为资源调用关系，出现锁等待的问题。 以上问题分析清楚之后，接下来才是要'对真正有性能问题的SQL'进行优化。 第四步，SQL优化，关于这块主要包括4点， 第一，Explain查看SQL执行计划； 第二，SQL改写； 第三，索引调整； 第四，参数调整。 总结如下： 构建完备的监控体系 细致合理的告警 多维度图形化指标 暴露性能缺陷，掌控大规模资源 分析定位问题 异常时间区间 System log、 DB Error Log Slow Log SQL执行统计 session 分析业务逻辑 读写需求 事务精简 资源调用关系 SQL优化 explain SQL改写 索引调整 参数调整 SQL优化原则与方法 1.优化原则 'SQL优化原则'主要有两点：'减少数据访问量'与'减少计算操作'。 (lincq：我把第一个理解为数据的扫描量) 1.减少访问量：'数据存取'是'数据库系统最核心功能'，所以'IO'是数据库系统中'最容易出现性能瓶颈'，'减少SQL访问IO量'是SQL优化的第一步； 数据块的逻辑读也是产生CPU开销的因素之一。 减少访问量的'方法'：'创建合适的索引'、'减少不必访问的列'、'使用索引覆盖'、'语句改写'。 2.减少计算操作：'计算操作进行优化'也是'SQL优化的重要方向'。SQL中'排序、分组、多表连接'操作等计算操作，都是'CPU消耗的大户'。 减少SQL计算操作的'方法'：'排序列加入索引'、'适当的列冗余'、'SQL拆分'、'计算功能拆分'。 关于SQL优化方法，包括5点 1）'创建索引减少扫描量' 2）调整索引减少计算量； 3）索引覆盖（减少不必访问的列，'避免回表查询'）； 4) SQL改写； 5）干预执行计划； 原理解析 b+tree索引 如上图所示，B+ Tree Index索引分为3个部分：根、枝、叶。 核心特点是根和枝不存储数据，行高比较固定。通过“B+Tree”索引'取数据'，'必然经过'根枝叶三个'节点路径'，取数据的'代价比较稳定'；另外一点，'叶子节点上的数据'是'有序存储'的。 Innodb Table Innodb 是MySOL的核心存储引擎，Innodb Table是lOT有序存储， 核心概念为：Innodb的表数据按照"B+Tree" 的结构进行组织，表数据本身是“B+Tree”索引的叶子节点。 如下图所示，'每张表'，也就是'每个存储段'，实际是在MySOL里构建了一个“B+ Tree”索引的树状结构，段的物理存储跟其他关系数据库的存储方式一样分区和块。 segment(段) extent(区,范围面积) page 索引检索过程 把二级索引理解为非主键索引 如上图所示有三个流程，上面两块是'二级索引'，下面是属于'主键索引'，也叫'聚集索引'，是'Innodb表的数据本身'，依次看这三个流程： 第一，非主键查询，入口是从二级索引，通过二级索引，第一个过程返回聚集索引的ID；第二个过程是回表，相当于再做一次数据检索，然后从聚集索引中获取数据。 第二，'主键查询'，入口是直接通过聚集索引的ID，可以在聚集索引中获取数据。 第三，'覆盖索引'，入口是二级索引，直接从二级索引当中获取数据。 MySQL的行为 MySQL SQL执行过程 1. 执行过程示例 如上图所示，MySQL的执行的过程包括： 1）客户端提交一条语句； 2）先在查询缓存查看是否存在对应的缓存数据，如有则直接返回(一般有的可能性极小，因此一般建议关闭查询缓存）； 3）交给'解析器'处理，解析器会将提交的语句'生成一个解析树'； 4）'预处理器'会处理解析树，'形成新的解析树'。这一阶段'存在一些SQL改写的过程'； 5）'改写后的解析树'提交给'查询优化器'。查询优化器'生成执行计划'； 6）'执行计划'交由执行引擎调用存储引擎接口，完成执行过程。这里要注意，'MySQL的Server层和Engine层是分离的'； 7）'最终的结果'由'执行引擎返回'给客户端，如果'开启查询缓存'的话，则会缓存。 2.SQL执行顺序 (8) SELECT (9) DISTINCT (1) FROM (3) JOIN (2) ON (4) WHERE (5) GROUP (6) WITH {CUBE|ROLLUP} (7) HAVING (10) ORDER BY (11) LIMIT 关于SQL的执行顺序，在某些时候也可以给我们一些指导性建议。比如Where条件和Order by，在通常情况下，SQL语 句先获取数据，再做Select操作，先获取数据再返回到Server端结果集的存储区之后进行排序，从这里我们可以假设如 果通过索引获取数据，那么在取数据时，数据排序就已经完成，相当于MySQL存储引擎的层面已经做了优化，而不需要 再增加额外的排序计算操作。 MySQL优化器与执行计划 1.查询优化器 '查询优化器的主要作用'是用'来负责生成SQL语句的执行计划'。优化器是'数据库的核心价值'所在，它是数据库的“大脑” 优化SQL某种意义上就是理解优化器的行为。 在MySQL里面，'优化的依据'是执行成本，它的本质是CBO，也就是说'执行计划的生成是基于成本'的。目前MySQL优化 器没有那么完善，执行成本主要'基于行数'而定。优化器'工作的前提'是了解数据，'工作的目的'是'解析SQL，生成执行计划'。 总结如下： 负责生成 SQL 语句的有效执行计划的数据库组件； 优化器是数据库的核心价值所在，它是数据库的“大脑” 优化SQL，某种意义上就是理解优化器的行为； 优化的依据是执行成本(CBO)； 优化器工作的前提是了解数据，工作的目的是解析SQL，生成执行计划。 2.查询优化器工作过程 如上图所示，查询优化器工作过程包括： 1）'词法分析'、'语法分析'、'语义检查'； 2）预处理阶段（查询改写等）； 3）查询优化阶段，可详细划分为'逻辑优化'、'物理优化'两部分 逻辑优化：把SQL交给查询优化器之后，会去做相应的'改写'动作。 物理优化：过程是优化器'生成'获取去扫描数据的'路径'。 4）查询优化器'优化依据'，'来自于' '代价估算器估算结果'(它会调用统计信息作为计算依据)； 5）交由执行器执行。 3.查看和干预执行计划 在MySQL里查看SQL的执行计划'直接通过Explain关键词'就可以了，或者我们可以'添加Extended关键字'，它会展示 MySQL优化器的逻辑优化改写过程。 1.执行计划 explain [extended] SOL Statement explain select * from payment where rental _=d > 1000 order by payment_date; id :1 select_type :SIMPLE table:payment ALL type:fk_payment_rental possible keys:NULL key:NULL key_ler:NULL ref:15511 rows:Using where; Extra:Using filesort 1 row in set (0.00 sec) 对于MySQL执行计划的获取，我们可以通过explain方式来查看，explain方式看似简单，实际上包含的内容很多， 尤其是输出结果中的type类型列。理解这些不同的类型，对于我们SQL优化举足轻重， 本文仅描述explian输出结果中的type列，同时给出其演示。 有关explian输出的全描述，可以参考：MySQL EXPLAIN SQL 输出信息描述 一、EXPLAIN 语句中type列的值type： 连接类型 system 表只有一行 const '表最多只有一行匹配'，通用用于'主键'或者'唯一索引'比较时 eq_ref 每次与之前的表合并行都只在该表读取一行，这是'除了system，const之外最好的一种'，'特点是使用='， 而且索引的所有部分都参与join且索引是主键或非空唯一键的索引 ref 说明：如果每次只'匹配少数行'，那就是比较好的一种，'使用=或<=>'，可以是'左覆盖索引'或'非主键'或'非唯一键' eg:非唯一性索引扫描或者，返回'匹配某个单独值的所有行'。常见于使用'非唯一索引'即唯一索引的非唯一前缀进行的查找 explain select * from payment where customer_id=305\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: payment type: ref possible_keys: idx_fk_customer_id key: idx_fk_customer_id key_len: 2 ref: const rows: 25 Extra: 1 row in set (0.00 sec) ps:'idx_fk_customer_id'为表payment上的'外键索引'，且'存在多个不同的值' fulltext 全文搜索 ref_or_null 与ref类似，但包括NULL index_merge 表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。 这个比较复杂，目前的理解是'合并单表的范围索引扫描'（如果成本估算比普通的range要更优的话 unique_subquery 在in子查询中，就是value in (select...)把形如“select unique_key_column”的子查询替换。 PS：所以不一定in子句中使用子查询就是低效的！ index_subquery 同上，但把形如”select non_unique_key_column“的子查询替换 range index 常数值的范围 a.当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）； b.以索引顺序从索引中查找数据行的全表扫描（无 Using Index）； c.如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思； d.如单独出现，则是用读索引来代替读行，但不用于查找 all 全表扫描 当我们'认为SQL的执行计划不合理'时，可以通过'适当的手段'，'强制加索引'或者'强制驱动表的顺序'，通过这种hints方式干预 SQL的执行计划。另外'MySQL查询优化器'的一些'关键特性'，我们也可以通过控制优化器开关的参数，从而控制优化器相关的行为。 hints[提示，暗示] 2.优化器开关 show variables like 'optimizer_switch' mysql> show var iables Like 'opt optimizer_switch'\G Variable_name: opt optimizer_switch Value: index_ merge=on, index merge_ un ion=on, index merge_ sort. un ion=on， index_ merge. intersection=on, eng ine _condit ion pushdown=on, index_condit ion_ pushdown=on,mrr=on, mrr cost based=on, block_ nested_ Loop=on,batched key ac cess=off,materialization=on, semijo in=on, loosescan=on, firstmatch=on, duplicateweedout=on, subquery_ materialization cost based=on,use_ index_extens ions=on, condit ion_fanout_ filter=on, der ived merge=on T row in set (0.01 sec) 3.Processlist 另一种观测MySQL行为的常用手段就是Processlist。通过Processlist，我们可以看到当前在MySQL中执行的所有SQL 语句，有没有异常的会话或比较特殊的SQL状态。查看会话操作可以通过2种途径： 第一，show [full] processlist; 第二，information_schema.processlist。 这里列出了几种常见的异常行为： 1）Copy to tmp table 出现在某些Alter Table语句的Copy Table操作。 注：当Where条件中的过滤字段为覆盖索引的前缀列，而Order by字段是第二个索引列时，只有Where条件是Const匹配 时，才可以通过索引消除排序，而between…and或>?、