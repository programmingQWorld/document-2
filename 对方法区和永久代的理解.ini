对方法区和永久代的理解

笨比乔治

    目前有三大Java虚拟机：HotSpot，oracle JRockit，IBM J9。

    JRockit是oracle发明的，用于其WebLogic服务器，I
    BM JVM是IBM发明的用于其Websphere服务器（所以'在某行开发'的时候，他们'用的是IBM的JDK'，
    因为他们使用的IBM的应用程序服务器Websphere，使用其他JDK'可能存在兼容性问题'）。

    JRockit和J9不存在永久代这种说法。这里'只讨论HotSpot虚拟机'，
    这也是目前使用的最多的JVM。Sun JDK7 HotSpot'虚拟机的内存模型'如下图所示：

        方法区(Method Area)
        虚拟机栈 + 本地方法栈 (VM Stack + Native Method Stack). 线程隔离的数据区域
        程序计数器(Program Counter Register) 线程隔离的数据区域
        堆空间(Heap)
            新生代 (1/3 heap)
                Eden (8/10)
                from (1/10)
                to (1/10)
            老年代 (2/3 heap)


    1、什么是方法区
        一、方法区与永久代

        这两个是'非常容易混淆的概念'，'永久代的对象' '放在方法区'中，就会'想当然地认为'，方法区就等同于永久代的内存区域。
        
        事实上两者是这样的关系：

        《Java虚拟机规范》只是规定了有'方法区'这么个'概念'和'它的作用'，并没有规定如何去实现它。
        那么，在'不同的 JVM' 上'方法区的实现'肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。
        
        '在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。'
        '换句话说'：'方法区是一种规范'，'永久代是Hotspot针对这一规范的一种实现'。而'永久代本身也在迭代中'：


        建议读一下<深入理解java虚拟机>这本书.这里面是这样'阐述方法区'的:
        用于存储'已经被JVM加载的类信息,常量,静态变量等'.虽然JVM规范'把方法区描述为堆的一个逻辑部分',
        但是他却有另外的一个'别名叫做Non-Heap(非堆)',目的是跟JVM的方法区分开来.
        很多人把方法区称为永久代,但是两者其实并不等价.永久代只是来实现方法区而已,
        这样HotSpot可以'像管理java的堆内存一样管理这部分的内存,能够省去专门为方法区编写内存代码管理的工作'.

        在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在native memory的CodeCache区域，其他都存放在永久代；
        在Java 7中，Symbol的存储从PermGen移动到了native memory，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）；
        在Java 8中，'永久代被彻底移除'，'取而代之'的是另一块'与堆不相连的本地内存'——'元空间'（Metaspace）,
        '‑XX:MaxPermSize 参数失去了意义，取而代之的是-XX:MaxMetaspaceSize'。

        对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？
        当然不是，方法区是一个规范，规范没变，它就一直在。那么'取代永久代的就是元空间'。
        元空间与永久代有什么不同的？

        '存储位置不同'，永久代是方法区的一部分，和新生代，老年代地址是连续的，而'元空间属于本地内存'；

        '存储内容不同'，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。

        二、方法区里存着什么？
            既然永久代是方法区的一种实现，那么在Hotspot下，方法区就等于永久代，也被称为非堆。
            那方法区里都存着什么呢？先抛结论：

            '静态变量 + 常量 + 类信息(构造方法/接口定义) + 运行时常量池'存在方法区中 。

    2、方法区和永久代的关系
        
        在Java虚拟机规范中，方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是'简单的虚拟机实现' '可以选择不在方法区实现垃圾回收与压缩'。
        这个版本的虚拟机规范'也不限定实现方法区的内存位置和编译代码的管理策略'。
        所以不同的JVM厂商，针对自己的JVM可能有不同的方法区实现方式。

        永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。
        '在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间。'
        永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了'在应用里使用的类和方法'。
        注意，永久代不是Java堆内存的一部分。永久代存放JVM运行时使用的类。'永久代同样包含了Java SE库的类和方法'。
        '永久代的对象' '在full GC时进行垃圾收集'。

        在HotSpot中，设计者将方法区纳入GC分代收集。HotSpot虚拟机堆内存被分为新生代和老年代，对堆内存进行分代管理。

        方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，
        而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。

        我们知道在HotSpot虚拟机中存在'三种垃圾回收现象'，minor GC、major GC和full GC。
        对新生代进行垃圾回收叫做minor GC，
        对老年代进行垃圾回收叫做major GC，
        同时对新生代、老年代和永久代进行垃圾回收叫做full GC。
        
        许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。
        'major GC和full GC通常是等价的，收集整个GC堆。' (因为有的地方通常认为，对老年代的回收就是full gc了)
        
        但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，
        当有人说“major GC”的时候一定要问清楚他想'要指的是上面的full GC还是major GC'。

    3、元空间
        上面说过，HotSpot虚拟机在1.8之后已经取消了永久代，改为元空间，
        类的元信息被存储在元空间中。'元空间没有使用堆内存，而是与堆不相连的本地内存区域'。
        所以，理论上系统可以使用的内存有多大，元空间就有多大，所以'不会出现内存溢出问题（永久代则会有这个问题）'。
        这项改造也是有必要的，'永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小'，
        因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。
        永久代中的元数据的位置也会随着一次full GC发生移动，比较消耗虚拟机性能。
        
        同时，HotSpot虚拟机的'每种类型的垃圾回收器'都需要'特殊处理永久代中的元数据'。
        将元数据从永久代剥离出来，不仅实现了'对元空间的无缝管理'，还可以'简化Full GC'以及'对以后的并发隔离类元数据'等方面进行优化。


文章2
一、新生代

    新生代主要用来存放新生的对象。
    一般占据堆空间的1/3。在新生代中，保存着大量的刚刚创建的对象，
    但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行MinorGC，进行垃圾回收。

    新生代又细分为三个区：Eden区、SurvivorFrom、ServivorTo区，三个区的默认比例为：8：1：1。

    Eden区：Java新创建的对象绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。
    当Eden区内存不够的时候，就会触发MinorGC（新生代采用的是复制算法），对新生代进行一次垃圾回收。

    SurvivorFrom区和To区：在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，
    一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，
    然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，
    如果对象的年龄达到15，则直接分配到老年代。
    
    MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。
    下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。

二、老年代

    老年代主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行MajorGC。
    而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。
    
    当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。

    在老年代中，MajorGC采用了标记—清除算法：
    首先扫描一次所有老年代里的对象，标记出存活的对象，然后回收没有标记的对象。
    MajorGC的耗时比较长。因为要扫描再回收。
    
    MajorGC会产生内存碎片，当老年代也没有内存分配给新来的对象的时候，就会抛出OOM（Out of Memory）异常。

三、永久代

    永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。
    Classic在被加载的时候被放入永久区域，它和存放的实例的区域不同，
    
    在Java8中，词锋代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。
    元空间和永久代类似，都是对JVM中规范中方法的实现。
    
    不过'元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存'。
    因此，默认情况下，元空间的大小仅受本地内存的限制。
    
    '类的元数据放入native memory'，'字符串池和类的静态变量' '放入java堆中'。
    
    这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

    采用元空间而不用永久代的原因：

        为了解决'永久代的OOM问题'，元数据和class对象存放在永久代中，容易出现性能问题和内存溢出。
        类及方法的信息等'比较难确定其大小'，因此'对于永久代大小指定比较困难'，
        太小容易出现永久代溢出，太大容易导致老年代溢出（'堆内存不变，此消彼长'）。
        '永久代会为GC带来不必要的复杂度'，并且'回收效率偏低'。