'什么是SpringBoot？'
        1、'约定大于配置,' 用来'简化spring初始搭建和开发过程' 使用特定的方式进行配置(properties或者yml文件)
        2、创建独立的spring应用程序，'通过main方法运行'
        3、嵌入Tomcat无需部署war包，直接打成jar包 'nohup java -jar – &' 启动就好
        4、'简化了maven的配置'
        4、'自动配置spring' -- 添加对应的starter,'则完成自动化配置'


SpringBoot的'优点'：
    1、减少开发、测试时间
    2、使用JavaConfig有助于避免使用XML
    3、'避免大量的maven依赖和各种版本冲突'
    4、提供意见发展方法
    5、通过提供默认值快速开始开发
    6、没有单独的web服务器需要，这就意味着不再需要启动Tomcat、Glassfish或其他任何东西
    7、需要更少的配置，因为没有web.xml文件。只需添加用@Configuration注释的类，然后添加用@Bean注释的方法，Spring将自动加载对象并像以前一样对其进行管理。甚至可以将@Autowired添加到bean方法中，以使用Spring自动装入需要的依赖关系中


'SpringBoot常用的starter'：
    1、spring-boot-starter-web(嵌入Tomcat和web开发需要的servlet和jsp支持)
    2、spring-boot-starter-data-jpa(数据库支持)
    3、spring-boot-starter-data-Redis(Redis支持)
    4、spring-boot-starter-data-solr(solr搜索应用框架支持)
    5、mybatis-spring-boot-starter(第三方mybatis集成starter)

'SpringBoot自动配置原理：'

    1、'@EnableAutoConfiguration'这个注解会推断你将如何配置spring，
    前提是你已经添加了jar依赖项，如果spring-boot-starter-web已经添加Tomcat和SpringMVC，
    这个注释就会自动'假设您在开发一个web应用程序' 并'添加相应的spring配置'，
    会自动去maven中读取每个starter中的'spring.factories文件'，该文件里'配置了所有需要被创建的bean'(存到spring容器中)

    2、在main方法中加上'@SpringBootApplication'和'@EnableAutoConfiguration'


'SpringBoot starter工作原理'：
    
    1、'SpringBoot在启动时' '扫描项目依赖的jar包'，寻找'包含 spring.factories 文件的jar'
    2、'根据spring.factories配置' '加载AutoConfigure'
    3、根据@Conditional注解的条件，进行'自动配置并将bean注入到Spring Context'




Springcloud解决那些问题：
'配置管理'、（注册中心eureka、zk）、'服务发现、服务注册'、断路器、路由策略、全局锁、分布式会话、客户端调用、接口网关（zuul）、服务管理系统
SpringBoot与Springcloud：
1>、SpringBoot'简化了xml配置，快速整合框架'
2>、Springcloud是一套'微服务解决方案'—'RPC远程调用'
3>、关系Springcloud依赖与SpringBoot（web组件用的SpringMVC），为什么Springcloud会依赖与SpringBoot？因为Springcloud'写接口就是SpringMVC接口'
4>、SpringBootproperties和yml中可以使用${random}设置一些随机值

服务的调用：
    rest、feign（均使用httpclient技术），负载均衡ribbon
    服务调用的原理：服务首先注册到注册中心eureka中(注册一个名字通过名字调用)
负载均衡
    ribbon，先去注册中心取到对应的服务，然后交给ribbon
    配置详解：
        eureka.client.register-with-eureka：'是否向注册中心注册自己，注册为true反之为false'
        eureka.client.fetch-registry： '是否需要去检索服务'，检索为true反之为false
        eureka.client.serviceUrl.defaultZone : '指定服务注册中心的地址'
Eureka：
    1>、eureka可分为三个角色：'服务发现者'、'服务注册者'、'注册发现中心'，但是这三个角色并不和实际部署的模型是一对一的关系
    2>、所有的网络通信都是'基于http(s)协议'的
    3>、Eureka和AWS是紧密结合的，无论是配置还是源码，比如Region、zone…，Region可以通过配置文件进行配置，
    如果不配置默认使用us-east-1。同样Zone也可以配置，若不配置默认使用defaultZone

    高可用配置：
    'Eureka server 的高可用'实际上就是'将自己作为服务' '向其他服务注册中心' '注册自己'，
    这样就可以'形成一组互相注册的服务注册中心'，以'实现服务清单的互相同步'，'达到高可用效果'。

微服务：
以前所有的代码都放在同一个工程中、部署在同一个服务器、同一项目的不同模块不同功能互相抢占资源，
微服务就是将工程根据不同的业务规则拆分成微服务，部署在不同的服务器上，服务之间相互调用，
java中有的微服务有dubbo(只能用来做微服务)、springcloud( 提供了服务的发现、断路器等)。

微服务的特点：
    '按业务划分为一个个独立运行的程序'，即服务单元
    服务之间'通过HTTP协议相互通信'
    '自动化部署'
    可以用不同的编程语言
    可以用不同的存储技术
    服务集中化管理
    '微服务是一个分布式系统'

微服务的优势：
    1、将一个复杂的业务拆分为若干小的业务。因为代码体积变小，逻辑更加专一，接手成本较低。
    2、由于微服务是'分布式'服务，'服务与服务之间没有任何耦合'。微服务系统的'微服务单元具有很强的横向拓展能力'。
    3、'服务与服务之间'采用'HTTP网络通信协议'来通信，单个服务内部高度耦合，服务与服务之间完全独立，无耦合。
        这使得微服务'可以采用任何的开发语言和技术来实现'，'提高开发效率、降低开发成本'。
    4、微服务是'按照业务进行拆分的'，并'有坚实的服务边界'，若要重写某一业务代码，不需了解所有业务，重写简单。
    5、微服务的每个服务单元是'独立部署'的，即独立运行在某个进程中，'微服务的修改和部署' '对其他服务没有影响' (除了接口内容更新，出现了不兼容的情况)。
    6、微服务在CAP理论中采用的'AP架构'，具有'高可用分区容错'特点。高可用主要体现在'系统7x24不间断服务'，他'要求系统有大量的服务器集群'，从而提高系统的负载能力。'分区容错也使得系统更加健壮'。
微服务的不足：
    1、'微服务的复杂度'：构建一个微服务比较复杂，服务与服务之间通过HTTP协议或其他消息传递机制通信，开发者要'选出最佳的通信机制'，并'解决网络服务差时带来的风险'。
    2、分布式事务：将事务分成'多阶段提交'，如果'一阶段某一节点失败'仍会导致数据不正确。
        '如果事务涉及的节点很多'，'某一节点的网络出现异常' '会导致整个事务处于阻塞状态'，'大大降低数据库的性能'。
    3、服务划分：将一个'完整的系统拆分成很多个服务'，是一件非常困难的事，因为这涉及了'具体的业务场景'
    4、服务部署：'最佳部署容器Docker'

微服务和SOA的关系：

'微服务比SOA轻便敏捷的多'，微服务将'复杂的业务' '组件化'，也是一种'面向服务思想'的体现。更加轻便、敏捷和简单
但是具体怎么轻便敏捷，也没有说明。。。

springcloud'如何实现服务注册与发现'？

服务发布时指定对应的服务名(IP地址和端口号)，'将服务注册到注册中心'(eureka和zookeeper)，
但是这一切是Springcloud自动实现的，'只需要在SpringBoot的启动类上' '加上@EnableDisscoveryClient注解'，
同一服务修改端口就可以启动多个实例调用方法：'传递服务名称'通过'注册中心获取所有的可用实例'，'通过负载均衡策略'(Ribbon和Feign)'调用对应的服务'


Ribbon和Feign的区别：

具体区别：
1、'启动类使用的注解不同'，Ribbon使用的是@RibbonClient，Feign使用的是@EnableFeignClients
2、'服务的指定位置不同'，Ribbon是在'@RibbonClient注解'上声明，Feign则是'在定义抽象方法的接口中' '使用@FeignClient声明'
3、调用方式不同，Ribbon'需要自己构建http请求'，'模拟http请求'然后'使用RestTemplate发送给其他服务'，'步骤比较繁琐'。
    Feign则是在Ribbon的基础上进行了一次改进，'采用接口调用的方式'，将'需要调用的其他服务的方法定义成抽象方法即可'，
    不需要自己构建http请求，不过要注意的是'抽象方法的注解、方法签名要和提供方的完全一致'。


雪崩效应：
    分布式系统中的'服务通信依赖于网络'，'网络不好'，必然会对分布式系统带来'很大的影响'。在分布式系统中，服务之间相互依赖，
    如果'一个服务之间出现了故障或者网络延迟'，会导致调用方线程阻塞直到接口返回，在高并发的情况下，该'服务消费方的线程资源会消耗殆尽'，最终'使得该服务不可用'。
    由于'服务的相互依赖'，可能会'导致整个系统不可用'，这就是“'雪崩效应'”。
    为了防止此类事件的发生，分布式系统必然要采取相应的措施，如'熔断机制'（Springcloud采用的是'Hystrix'）

熔断机制：
    1、当一个'目标服务出现故障'时，'服务消费方' '请求失败次数' '超过设定的阀值'（'默认50'）之后，'该服务就会开启熔断器'，
    之后'该服务就不进行任何业务逻辑操作'，'执行快速失败'，'直接返回请求失败的信息'。
    '其他依赖于该服务的服务'就'不会因为得不到响应' '而造成线程阻塞'，'这时候'除了该服务和依赖于该服务的'部分功能不可用'外，'其他功能正常'。
    2、熔断器还有一个'自我修复机制'，'当一个服务熔断后'，经过'一段时间'（5s）会'检查一部分请求'（只能有一个请求）'是否正常'，
        其他请求执行快速失败，'检查的请求如果响应成功，则可判断该服务正常'了，就'可关闭该服务的熔断器'，反之则'继续打开熔断器'。
        这种'自我熔断机制'和'自我修复机制'可以'使程序更加健壮'、也可以'为开发和运维减少很多不必要的工作'。
    3、熔断组件往往会提供一系列的监控，如：'服务可用与否'、'熔断器是否被打开'、目前的吞吐量、'网络延迟状态的监控'等，从而可以让开发人员和运维人员的了解服务的状况。


Eureka基础架构：

    '服务注册中心'：'Eureka提供的服务端'，提供'服务注册与发现'的功能
        
        '失效剔除'：对于那些'非正常下线的服务实例'（内存溢出、网络故障导致的），服务注册中心'不能正常收到' '“服务下线”的请求'，
        为了将这些'无法提供服务的实例' '从服务列表中剔除'，Eureka Server在启动的时候会创建一个'定时任务'，
        默认'每隔一段时间（默认60s）'将当前清单中超时（默认90s）'没有续约的服务' '剔除出去'。

        '自我保护'：Eureka Server 在运行期间，会'统计心跳失败的比例' '在15分钟之内是否低于85%'，
        '如果出现低于的情况'（生产环境由于网络不稳定会导致），Eureka Server会'将当前的实例注册信息保护起来'，'让这些实例不过期'，尽可能保护这些注册信息，
        但是在这'保护期间内实例出现问题'，那么'客户端'就很'容易拿到'实际上'已经不存在的服务实例'，会'出现调用失败'的情况，
        所以'客户端必须有容错机制'，比如'可以使用请求重试、断路器等机制'。
        
        在'本地进行开发时'可以使用 'eureka.server.enable-self-preseervation=false' 参数来 '关闭保护机制'，'以确保注册中心可以将不可用的实例剔除'。

    '服务提供者'：提供服务的应用，可以是'SpringBoot应用'也可以是'其他的技术平台且遵循Eureka通信机制的应用'。
    他'将自己提供的服务' '注册到Eureka'，以'供其他应用发现'，（如：service层）

        1.'服务注册'：服务提供者'在启动的时候'会通过'发送Rest请求'的方式将自己'注册到Eureka Server'（服务注册中心）中，同时'带上自身服务的一些元数据'，
        Eureka Server 接收到这个Rest请求后，'将元数据存储在一个双层结构Map中'，第一层的key是'服务名'，第二层key是'具体服务的实例名'

        2.'服务同步'：若有'两个或两个以上的Eureka Server'（服务注册中心）时，他们之间是'互相注册'的，当'服务提供者发送注册请求'到一个'服务注册中心'时，它会'将该请求转发到集群中相连的其他注册中心'，从而实现'注册中心间的注册表信息同步'，这样'服务提供者的服务信息'可以'通过任意一台服务中心获取到'
        3.'服务续约'：在注册完服务之后，服务提供者会'维护一个心跳'来持续告诉Eureka Server：“我还活着”，'以防止Eureka Server的“剔除任务”' '将该服务实例从服务列表中排除出去'。配置：eureka.instance.'lease-renewal-in-seconds'=30('续约任务的调用间隔时间，默认30秒'，
        也就是每隔30秒向服务端发送一次心跳，证明自己依然存活)，eureka.instance.'lease-expiration-duration-in-seconds'=90(服务失效时间，默认90秒，也就是告诉服务端，'如果90秒之内没有给你发送心跳就证明我“死”了'，将我剔除)

    '服务消费者'：'消费者应用'从'服务注册中心获取服务列表'，从而使消费者可以知道'去何处调用其所需要的服务'，如：'Ribbon实现消费方式'、'Feign实现消费方式'
        '获取服务'：当启动服务消费者的时候，它会发送一个Rest请求给注册中心，获取上面注册的服务清单，Eureka Server会维护一份只读的服务清单来返回给客户端，并且每三十秒更新一次
        '服务调用'：在'服务消费者获取到服务清单'后，'通过服务名'可以'获得具体提供服务的实例名和该实例的元信息'，采用'Ribbon实现负载均衡' [负载均衡方式获取服务信息]
        '服务下线'：当服务实例进行'正常的关闭操作'时，它会触发一个'服务下线的Rest请求'给Eureka Server，告诉服务注册中心“我要下线了”。服务端接收到请求之后，将该'服务状态设置为下线'，并'把下线时间传播出去'。

'Eureka和zookeeper'都可以提供'服务注册与发现'的功能，'两者的区别'：'Zookeeper保证了CP'(C：'一致性'，P：'分区容错性')，'Eureka保证了AP'(A：高可用，P：分区容错)

    1、Zookeeper-----当'向注册中心查询服务列表'时，我们可以'容忍注册中心返回的是几分钟以前的信息'，但'不能容忍直接down掉不可用的'。
    也就是说服务注册功能'对高可用性要求比较高'，但是zk会出现这样的一种情况，'当master节点因为网络故障与其他节点失去联系时'，'剩余的节点会重新选leader'。
    问题在于，'选取leader的时间过长'(30~120s)，且'选取期间zk集群都不可用'，这样就会导致'选取期间' '注册服务瘫痪'。
    在'云部署的环境'下，因'网络问题'使得'zk集群失去master节点'是'较大概率会发生的事'，虽然服务最终恢复，但是'漫长的选择时间'导致的注册长期'不可用是不能容忍'的

    2、Eureka则看明白这一点，因此再设计的'优先保证了高可用性'。'Eureka各个节点都是平等的'，几个节点挂掉不会影响到正常节点的工作，剩余的节点依然可以'提供注册和查询服务'。
    而'Eureka的客户端'再'向某个Eureka注册时' '如果发现连接失败'，则'会自动切换至其他节点'，
    '只要有一台Eureka'还在，就'能保证注册服务的可用'(保证可用性)，只不过'查到的信息' '可能不是最新的'('不保证一致性')。
    除此之外Eureka还有一种'自我保护机制'，如果在15分钟内超过85%的节点都没有正常心跳，那么Eureka就认为'客户端与注册中心出现了网络故障'，此时就会出现以下几种情况：
        1>、Eureka不再从注册列表移除因为长时间没收到心跳而应该过期的服务
        2>、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(保证当前节点可用)
        3>、当网络稳定时，当前实例新的注册信息会被同步到其它节点中
    Eureka还有'客户端缓存功能'(Eureka分为客户端程序和服务器端程序两个部分，客户端程序负责向外提供注册与发现服务接口)。
    所以'即便Eureka集群中所有节点都失效'，或者'发生网络分隔故障' 导致客户端不能访问任何一台Eureka服务器；
    Eureka服务的消费者任然可以'通过Eureka客户端缓存'来获取所有的'服务注册信息'。
    这点很重要，因此Eureka可以'很好的应对'网络故障导致'部分节点失去联系的情况'，而'不像Zookeeper那样使整个注册服务瘫痪'。

CAP理论：
1、Consistency：指数据的强一致性。如果写入某个数据成功，之后读取，读到的都是新写入的数据；如果写入失败，读到的都不是写入失败的数据。
2、Availability：指服务的可用性
3、Partition-tolerance：指分区容错

Ribbon和Nginx的区别：
'Nginx性能好，但Ribbon可以剔除不健康节点'，'Nginx剔除比较麻烦'，
'Ribbon是客户端负载均衡'，'Nginx是服务端负载均衡'

客户端负载均衡与服务端负载均衡的区别
    '服务端的负载均衡'是一个'url先经过一个代理服务器'（这里是nginx），然后通过这个'代理服务器' 通过'算法'（轮询，随机，权重等等）'反向代理你的服务'，来'完成负载均衡'。
    而客户端的负载均衡则是'一个请求在客户端的时候' 已经通过eureka'获取了要调用服务的集群信息'，然后'通过具体的负载均衡算法'来完成'调用具体某个服务'。

    简而言之，服务端负载均衡需要'先经过nginx代理服务器'才能知道'调用服务的集群信息'。
    而客户端负载均衡请求'在客户端的时候就已经知道了调用服务的集群信息'。


服务注册与发现：
    服务注册就是'向服务注册中心注册一个服务实例'，'服务提供者'将自己的服务信息（服务名、IP地址等）告知注册中心。
    服务发现是服务消费另一个服务时，注册中心将服务的实例返回给服务消费者，一个服务既是服务提供者又是服务消费者。
    服务注册中心'健康检查机制'，当一个'服务实例注册成功'以后，会'定时向注册中心发送一个心跳'证明自己可用，'若停止发送心跳'证明'服务不可用'将'会被剔除'。
    若过段时间继续想注册中心提供心跳，将会重新加入服务注册中心列表中。

服务的负载均衡：
为什么要用：
微服务是将业务代码'拆分为很多小的服务单元'，服务之间的相互调用通过HTTP协议来调用，
为了保证'服务的高可用'，服务单元往往都是'集群化部署'的，那么'消费者该调用那个服务提供者的实例'呢？

介绍：服务消费者'集成负载均衡组件'，该组件会向服务消费者'获取服务注册列表信息'，并'隔一段时间' '重新刷新获取列表'。
当服务消费者消费服务时，'负载均衡组件'获取服务提供者所有实例的注册信息，并通过一定的'负载均衡策略'（可以自己配置）'选择一个服务提供者实例'，
向该实例'进行服务消费'，这样就'实现了负载均衡'。