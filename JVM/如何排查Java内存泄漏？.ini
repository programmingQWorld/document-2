如何排查Java内存泄漏？看完我给跪了！

没有经验的程序员经常认为Java的自动垃圾回收完全使他们免于担心内存管理。
这是一个常见的误解：虽然垃圾收集器做得很好，但即使是最好的程序员也完全有可能成为严重破坏内存泄漏的牺牲品。

让我解释一下。

当'不必要地维护' '不再需要的对象引用'时，会'发生内存泄漏'。会'对计算机施加不必要的压力'。

实际上有'四类内存问题' '具有相似和重叠的特征'，但原因和解决方案各不相同：

    Performance('性能'): 与这几种情况相关联，'过多的对象创建和删除'，'垃圾收集的长时间延迟'，'过多的操作系统页面交换'等。
    Resource constraints('资源约束')：当'可用内存很少'或'内存过于分散'而'无法分配大对象'时 - 这可能是本机的，或者更常见的是'与Java堆相关'。
    Java heap leaks('java堆泄漏'): 经典的内存泄漏，'Java对象在不释放的情况下' '不断创建新的对象'。这通常是'由潜在对象引用引起'的。
    Native memory leaks('本机内存泄漏'):与'Java堆之外'的任何不断增长的内存利用率相关联，例如'由JNI代码，驱动程序甚至JVM分配'。

在这个内存管理教程中，我将专注于Java堆漏洞，并概述一种'基于Java VisualVM报告检测此类泄漏的方法'，
并'利用可视化界面'来分析运行的情况。

但在您可以预防和发现内存泄漏之前，您应该了解它们的发生方式和原因。（注意：如果你能很好地处理错综复杂的内存泄漏，你可以跳过。）

1. 内存泄漏：基础
    对于初学者来说，将内存泄漏视为一种疾病，将Java的OutOfMemoryError（简称OOM）视为一种症状。
    但与任何疾病一样，'并非所有OOM都意味着内存泄漏'：
    由于生成大量局部变量或其他此类事件，OOM可能会发生。
    另一方面，并非所有内存泄漏都必然表现为OOM，特别是在桌面应用程序或客户端应用程序（没有重新启动时运行很长时间）的情况下。

    将内存泄漏视为疾病，将OutOfMemoryError视为症状。
    
    并非所有OutOfMemoryErrors都意味着内存泄漏，
    并非所有内存泄漏都表现为OutOfMemoryErrors。

    为什么这些泄漏如此糟糕？除此之外，程序执行期间泄漏的内存块通常会降低系统性能，
    因为分配但未使用的内存块必须在系统耗尽空闲物理内存时进行释放。
    最终，程序甚至可能耗尽其可用的虚拟地址空间，从而导致OOM。

2. 解密OutOfMemoryError
    如上所述，OOM是内存泄漏的常见指示。
    实质上，'当没有足够的空间来分配新对象时'，会抛出错误。
    当垃圾收集器找不到必要的空间，并且'堆不能进一步扩展'，会多次尝试。因此，会出现错误以及堆栈跟踪。

    诊断OOM的第一步是确定'错误的实际含义'。这听起来很清楚，但答案并不总是那么清晰。
    为了帮助您回答这个问题，让我们分析一些可能的错误消息：

        java.lang.OutOfMemoryError: Java heap space
        java.lang.OutOfMemoryError: PermGen space
        java.lang.OutOfMemoryError: Requested array size exceeds VM limit
        java.lang.OutOfMemoryError: request bytes for . Out of swap space?
        java.lang.OutOfMemoryError: (Native method)
    
    2.1.“Java heap space”
            此错误消息不一定意味着内存泄漏。实际上，问题可能与配置问题一样简单。

            例如，我'负责分析'一直产生这种类型的OutOfMemoryError的'应用程序'。
            经过一番调查后，我发现罪魁祸首是阵列实例化，因为'需要太多的内存';
            在这种情况下，并不是应用程序的错，而是应用程序服务器依赖于默认的堆太小了。
            我通过'调整JVM的内存参数'解决了这个问题。

            在其他情况下，特别是对于长期存在的应用程序，该消息可能表明我们无意中持有对象的引用，从而阻止垃圾收集器清理它们。这时Java语言等同于内存泄漏。（注意：应用程序调用的API也可能无意中持有对象引用。）

            这些'“Java堆空间”OOM'的另一个潜在来源是使用finalizers。
            如果类具有finalize方法，则在垃圾收集时该类型的对象不会被回收。
            而是在垃圾收集之后，稍后对象将排队等待最终确定。
            
            在Sun实现中，finalizers由守护线程执行。如果finalizers线程无法跟上finalization队列，
            那么Java堆可能会填满并且可能抛出OOM。

    2.2. “PermGen space”
        此错误消息表明'永久代已满'。永久代是存储类和方法对象的堆的区域。
        如果应用程序'加载了大量类'，则可能需要使用-XX：MaxPermSize选项'增加永久代的大小'。

        Interned java.lang.String对象也存储在永久代中。
        java.lang.String类维护一个字符串池。调用实习方法时，该方法检查池以查看是否存在等效字符串。
        如果是这样，它由实习方法返回;如果没有，则将字符串添加到池中。更准确地说，
        java.lang.String.intern方法返回一个字符串的规范表示;
        结果是对该字符串显示为文字时'将返回的同一个类实例的引用'。
        如果应用程序实例化大量字符串，则可能'需要增加永久代的大小'。

        注意：您可以使用'jmap -permgen命令'打印'与永久生成相关的统计信息'，包括'有关内部化String实例的信息'。

    2.3.“Requested array size exceeds VM limit”
        此错误表示应用程序（或该应用程序使用的API）'尝试分配大于堆大小的数组'。
        例如，如果应用程序'尝试分配512MB的数组'但'最大堆大小为256MB'，
        则将抛出此错误消息的OOM。
        
        在大多数情况下，问题是'配置问题或应用程序尝试分配海量数组时'导致的错误。

    2.4. “Request bytes for . Out of swap space?”
        
        此消息似乎是一个OOM。但是，'当本机堆的分配失败'并且'本机堆可能将被耗尽时'，
        HotSpot VM会抛出此异常。消息中包括失败请求的大小（以字节为单位）以及内存请求的原因。
        在大多数情况下，是报告分配失败的源模块的名称。

        如果抛出此类型的OOM，则可能需要在操作系统上使用故障排除实用程序来进一步诊断问题。
        在某些情况下，问题甚至可能与应用程序无关。例如，您可能会在以下情况下看到此错误：

        操作系统配置的交换空间不足。
        系统上的另一个进程是消耗所有可用的内存资源。
        由于本机泄漏，应用程序也可能失败（例如，如果某些应用程序或库代码不断分配内存但无法将其释放到操作系统）。

    2.5. Native method
        如果您看到此错误消息并且堆栈跟踪的顶部框架是'本机方法'，则该本机方法遇到分配失败。
        
        此消息与上一个消息之间的区别在于，
        '在JNI或本机方法中检测到Java内存分配失败'，
        而不是在Java VM代码中检测到。

        如果抛出此类型的OOM，您可能需要'在操作系统上使用实用程序'来进一步诊断问题。

    2.6. Application Crash Without OOM
        有时，'应用程序可能会在从本机堆分配失败后很快崩溃'。如果您运行的本机代码不检查内存分配函数返回的错误，则会发生这种情况。

        例如，如果没有可用内存，malloc系统调用将返回NULL。如果未检查malloc的返回，
        则应用程序在尝试访问无效的内存位置时可能会崩溃。
        根据具体情况，可能很难定位此类问题。

        在某些情况下，致命错误日志或崩溃转储的信息就足以诊断问题。
        如果确定崩溃的原因是'某些内存分配中缺少错误处理'，
        那么您'必须找到所述分配失败的原因'。
        
        与任何其他本机堆问题一样，系统可能'配置了但交换空间不足'，
        另一个进程可能'正在消耗所有可用内存资源'等。

3. 泄漏诊断
    在大多数情况下，诊断内存泄漏需要非常详细地了解相关应用程序。
    警告：该过程可能很长并且是迭代的。

    我们寻找内存泄漏的策略将相对简单：

        识别症状
        启用详细垃圾回收
        启用分析
        分析踪迹

    3.1. 识别症状
    
        正如所讨论的，在许多情况下，Java进程最终会抛出一个OOM运行时异常，
        这'是一个明确的指示，表明您的内存资源已经耗尽'。
        
        在这种情况下，您需要区分正常的内存耗尽和泄漏。
        分析OOM的消息并尝试根据上面提供的讨论找到罪魁祸首。

        通常，如果Java应用程序请求的存储空间超过运行时堆提供的存储空间，
        则'可能是由于设计不佳导致'的。
        例如，如果应用程序创建映像的多个副本或将文件加载到数组中，
        则当映像或文件非常大时，它将耗尽存储空间。这是正常的资源耗尽。
        该应用程序按设计工作（虽然这种设计显然是愚蠢的）。

        但是，如果应用程序在处理相同类型的数据时稳定地增加其内存利用率，则可能会发生内存泄漏。

    3.2. 启用详细垃圾收集
        '断言确实存在内存泄漏的最快方法之一'是'启用详细垃圾回收'。
        通常可以通过检查verbosegc输出中的模式来识别内存约束问题。

        具体来说，'-verbosegc参数' 允许您在每次垃圾收集（GC）过程开始时生成跟踪。
        也就是说，当内存被垃圾收集时，摘要报告会'打印到标准错误'，让您了解内存的管理方式。

        这是使用-verbosegc选项生成的一些典型输出：


        此GC跟踪文件中的每个块（或节）按递增顺序编号。要理解这种跟踪，您应该查看连续的分配失败节，并查找随着时间的推移而减少的释放内存（字节和百分比），同时总内存（此处，19725304）正在增加。这些是内存耗尽的典型迹象。

    3.3. 启用分析
        不同的JVM提供了生成跟踪文件以反映堆活动的不同方法，这些方法通常包括有关对象类型和大小的详细信息。
        这称为'分析堆'。

    3.4. 分析路径
        本文重点'介绍Java VisualVM生成的跟踪'。跟踪可以有不同的格式，
        因为它们可以由不同的Java内存泄漏检测工具生成，
        
        但它们背后的想法总是相同的：'在堆中找到不应该存在的对象块'，并'确定这些对象是否累积而不是释放'。
        特别感兴趣的是每次在Java应用程序中触发某个事件时已知的临时对象。
        应该仅存少量，但存在许多对象实例，通常表示应用程序出现错误。

        最后，解决内存泄漏需要您彻底检查代码。了解对象泄漏的类型可能对此非常有用，并且可以大大加快调试速度。

4. 垃圾收集如何在JVM中运行？
    在我们开始分析具有内存泄漏问题的应用程序之前，让我们首先看看'垃圾收集在JVM中的工作原理'。

    JVM使用一种称为跟踪收集器的垃圾收集器，
    它基本上通过暂停它周围的世界来操作，标记所有根对象（由运行线程直接引用的对象），
    并遵循它们的引用，标记它沿途看到的每个对象。

    Java基于分代假设-实现了一种称为分代垃圾收集器的东西，
    该假设表明创建的大多数对象被快速丢弃，而未快速收集的对象可能会存在一段时间。

    基于此假设，[Java将对象分为多代]
    (http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html
    #1.1. Generations|outline)。这是一个视觉解释：


    Young Generation -这是对象的开始。它有两个子代
    
    Eden Space -对象从这里开始。大多数物体都是在Eden Space中创造和销毁的。
    在这里，GC执行Minor GCs，这是优化的垃圾收集。
    执行Minor GC时，对仍然需要的对象的任何引用都将迁移到其中一个survivors空间（S0或S1）。

    Survivor Space (S0 and S1)-幸存Eden Space的对象最终来到这里。
    其中有两个，在任何给定时间只有一个正在使用（除非我们有严重的内存泄漏）。
    一个被指定为空，另一个被指定为活动，与每个GC循环交替。
    
    Tenured Generation - 也被称为老年代（图2中的旧空间），
    这个空间容纳存活较长的对象，使用寿命更长（如果它们活得足够长，则从Survivor空间移过来）。
    填充此空间时，GC会执行完整GC，这会在性能方面降低成本。
    如果此空间无限制地增长，则JVM'将抛出OutOfMemoryError' - Java堆空间。
    
    Permanent Generation -作为与终身代密切相关的第三代，永久代是特殊的，因为它保存虚拟机所需的数据，
    以描述在Java语言级别上没有等价的对象。例如，描述类和方法的对象存储在永久代中。
    Java足够聪明，可以为每一代应用不同的垃圾收集方法。
    使用名为Parallel New Collector的跟踪复制收集器处理年轻代。
    这个收集器阻止了这个世界，但由于年轻一代通常很小，所以暂停很短暂。

    有关JVM代及其工作原理的更多信息，
    请查阅Memory Management in the Java HotSpot™ Virtual Machine 。

5. 检测内存泄漏
    要查找内存泄漏并消除它们，您需要合适的内存泄漏工具。是时候使用Java VisualVM检测并删除此类泄漏。

    5.1. '使用Java VisualVM远程分析堆'
    VisualVM是一种工具，它提供了一个可视化界面，用于查看有关基于Java技术的应用程序运行时的详细信息。

    使用VisualVM，您可以查看与'本地应用程序'和'远程主机上运行的应用程序'相关的数据。
    您还可以捕获'有关JVM软件实例的数据'，并'将数据保存到本地系统'。

    为了从Java VisualVM的所有功能中受益，您应该运行Java平台标准版（Java SE）版本'6或更高版本'。

    Related: Why You Need to Upgrade to Java 8 Already

    5.2. '为JVM启用远程连接'
    在生产环境中，通常很难访问运行代码的实际机器。幸运的是，我们'可以远程分析我们的Java应用程序'。

    首先，我们需要'在目标机器上授予自己JVM访问权限'。
    为此，请使用以下内容'创建名为jstatd.all.policy的文件'：

    grant codebase "file:${java.home}/../lib/tools.jar"
    permission java.security.AllPermission;
    };

    创建文件后，我们需要使用jstatd - Virtual Machine jstat Daemon工具启用与目标VM的远程连接，
    如下所示：

    创建文件后，我们需要使用jstatd - Virtual Machine jstat Daemon工具启用与目标VM的远程连接，如下所示：

    jstatd -p <PORT_NUMBER>-J-Djava.security.policy=<PATH_TO_POLICY_FILE>
    例如：

    jstatd -p 1234-J-Djava.security.policy=D:\jstatd.all.policy
    通过在目标VM中启动jstatd，我们能够连接到目标计算机并远程分析应用程序的内存泄漏问题。

    5.3. '连接到远程主机'
    在客户端计算机中，打开提示并键入jvisualvm以打开VisualVM工具。

    接下来，我们必须在VisualVM中添加远程主机。
    当目标JVM启用以允许来自具有J2SE 6或更高版本的另一台计算机的远程连接时，
    我们启动Java VisualVM工具并连接到远程主机。如果与远程主机的连接成功，
    我们将看到在目标JVM中运行的Java应用程序，如下所示：

    要在应用程序上运行内存分析器，我们只需在侧面板中双击其名称即可。

    现在我们已经设置了内存分析器，让我们研究一个内存泄漏问题的应用程序，我们称之为MemLeak。

6. MemLeak
    当然，有很多方法可以在Java中创建内存泄漏。
    为简单起见，我们将一个类定义为HashMap中的键，但我们不会定义equals（）和hashcode（）方法。

    HashMap是Map接口的哈希表实现，因此它定义了键和值的基本概念：
    每个值都与唯一键相关，因此如果给定键值对的键已经存在于HashMap，它的当前值被替换。

    我们的密钥类必须提供equals（）和hashcode（）方法的正确实现。
    没有它们，就无法保证会生成一个好的密钥。

    通过不定义equals（）和hashcode（）方法，我们一遍又一遍地向HashMap添加相同的键，
    而不是按原样替换键，HashMap不断增长，无法识别这些相同的键并抛出OutOfMemoryError 。

    MemLeak类:

    package com.post.memory.leak;

    import java.util.Map;

    public class MemLeak {
    public final String key;

    public MemLeak(String key) {
    this.key =key;
    }

    public static void main(String args[]) {
    try {
    Map map = System.getProperties();
    for(;;) {
                    map.put(new MemLeak("key"), "value");
    }
    } catch(Exception e) {
                e.printStackTrace();
    }
    }
    } 
    注意：内存泄漏不是由于第14行的无限循环：无限循环可能导致资源耗尽，但不会导致内存泄漏。
    如果我们已经正确实现了equals（）和hashcode（）方法，
    那么即使使用无限循环，代码也能正常运行，因为我们在HashMap中只有一个元素。

    （对于那些感兴趣的人，这里有一些（故意）产生泄漏的替代方法。）

7. 使用Java VisualVM
    使用Java VisualVM，我们可以'对Java Heap进行内存监视'，并'确定其行为' '是否存在内存泄漏'。

    这是刚刚初始化后MemLeak的Java堆分析器的图形表示（回想一下我们对各代的讨论）：

    仅仅30秒之后，老年代几乎已满，表明即使'使用Full GC，老年代也在不断增长，这是内存泄漏的明显迹象'。

    '检测此泄漏原因的一种方法'如下图所示（单击放大），使用带有heapdump的Java VisualVM生成。
    在这里，我们看到50％的Hashtable $ Entry对象在堆中，而第二行指向MemLeak类。
    因此，内存泄漏是由MemLeak类中使用的哈希表引起的。


    最后，在OutOfMemoryError之后观察Java Heap，其中Young和Old代完全填满。


8. 结束语
    内存泄漏是最难解决的Java应用程序问题之一，因为症状多种多样且难以重现。在这里，我们概述了一种逐步发现内存泄漏并确定其来源的方法。但最重要的是，仔细阅读您的错误消息并注意堆栈跟踪 - 并非所有泄漏都像它们出现的那样简单。

9. 附录
    与Java VisualVM一起，还有其他几种可以执行内存泄漏检测的工具。
    许多泄漏检测器通过拦截对存储器管理例程的调用在库级别操作。
    
    例如，HPROF是一个与Java 2平台标准版（J2SE）捆绑在一起的简单命令行工具，用于堆和CPU分析。
    可以直接分析HPROF的输出，或将其用作JHAT等其他工具的输入。
    当我们使用Java 2 Enterprise Edition（J2EE）应用程序时，
    有许多堆转储分析器解决方案更友好，例如IBM Heapdumps for Websphere应用程序服务器。